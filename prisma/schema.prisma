// ---------- Datasource & Generator ----------
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ---------- Enums ----------
enum BookStatus {
  ONGOING
  FINISHED
  HIATUS
}

// +++ NEW: статус главы
enum ChapterStatus {
  OPEN
  CLOSED
}

enum ReactionTarget {
  CHAPTER
  POST
  COMMENT
}

enum CollabRole {
  OWNER
  EDITOR
  AUTHOR
  VIEWER
}

enum BookType {
  SOLO
  COOP
}

enum CharacterAppStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  NEEDS_CHANGES
  APPROVED
}


// ---------- Core ----------
model User {
  id             String    @id @default(cuid())
  email          String    @unique
  hashedPassword String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  emailVerifiedAt  DateTime?
  accounts       Account[]
  sessions       Session[]
  characterApplications CharacterApplication[]

  // username в User (будет @unique, NOT NULL — зажмём в SQL ниже)
  username String @unique

  profile          Profile?
  roles            UserRole[]
  books            Book[]
  pages            Page[]
  threads          ForumThread[]
  posts            ForumPost[]
  comments         Comment[]
  reactions        Reaction[]
  follows          Follow[]       @relation("UserFollows")
  followers        Follow[]       @relation("UserFollowers")
  notifications    Notification[]
  collaborators    Collaborator[]
  editAudits       EditAudit[]
  turns            TurnQueue[] // ← backref for TurnQueue.user
  chaptersAuthored Chapter[]      @relation("ChapterAuthor")
  BookFollow       BookFollow[]
  chapterPosts     ChapterPost[] // ← обратная связь из ChapterPost.author
}

model Profile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  displayName String
  bio         String?
  avatarUrl   String?
  bannerUrl   String?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

model CharacterApplication {
  id        String            @id @default(cuid())
  userId    String
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  name      String
  form      Json              // вся анкета (поля будем расширять без миграций)
  status    CharacterAppStatus @default(DRAFT)

  // модерация (MVP)
  moderatorId   String?
  moderatorNote String?

  lastSubmittedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, status, updatedAt(sort: Desc)])
  @@index([status, updatedAt(sort: Desc)])
}


// ---------- Pages ----------
model Page {
  id        String   @id @default(cuid())
  ownerId   String
  owner     User     @relation(fields: [ownerId], references: [id])
  slug      String
  title     String
  blocks    Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  collaborators Collaborator[]

  @@unique([ownerId, slug])
}

// ---------- Books & Chapters ----------
model Book {
  id        String     @id @default(cuid())
  ownerId   String
  owner     User       @relation(fields: [ownerId], references: [id])
  title     String
  slug      String
  tagline   String?
  coverUrl  String?
  status    BookStatus @default(ONGOING)
  type      BookType   @default(SOLO)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  chapters      Chapter[]
  tags          BookTag[]
  followers     Follow[]
  collaborators Collaborator[]
  turns         TurnQueue[]
  BookFollow    BookFollow[]

  @@unique([ownerId, slug])
}

model Chapter {
  id          String      @id @default(cuid())
  bookId      String
  book        Book        @relation(fields: [bookId], references: [id])
  index       Int
  title       String
  content     Json
  markdown    String?
  isDraft     Boolean     @default(true)
  publishedAt DateTime?
  version     Int         @default(1)
  publishRole CollabRole?

  // Автор главы (для фильтров/видимости черновиков)
  authorId String?
  author   User?   @relation(name: "ChapterAuthor", fields: [authorId], references: [id])

  // NEW: открыта/закрыта для постинга
  status ChapterStatus @default(OPEN)

  // NEW: дата последнего поста (для сортировки/списков)
  lastPostAt DateTime?

  // КАНОНИЧЕСКИЙ HTML тела интро
  contentHtml String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // NEW: посты внутри главы (append-only поток)
  posts ChapterPost[]

  comments   Comment[]
  editAudits EditAudit[]

  @@unique([bookId, index])
  @@index([bookId, isDraft, publishedAt(sort: Desc)])
  @@index([authorId])
  @@index([lastPostAt(sort: Desc)])
}

// +++ NEW: атом поста внутри главы
model ChapterPost {
  id        String  @id @default(cuid())
  chapterId String
  chapter   Chapter @relation(fields: [chapterId], references: [id], onDelete: Cascade)

  authorId String
  author   User   @relation(fields: [authorId], references: [id])

  contentMd   String
  contentHtml String? // заполнится в 1.7 (sanitize→render)
  createdAt   DateTime  @default(now())
  editedAt    DateTime?

  @@index([chapterId, createdAt, id]) // стабильный курсор (createdAt,id)
  @@index([authorId])
}

// ---------- Forum ----------
model ForumCategory {
  id      String        @id @default(cuid())
  slug    String        @unique
  title   String
  desc    String?
  threads ForumThread[]
}

model ForumThread {
  id         String        @id @default(cuid())
  categoryId String
  category   ForumCategory @relation(fields: [categoryId], references: [id])
  authorId   String
  author     User          @relation(fields: [authorId], references: [id])
  title      String
  slug       String
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  locked     Boolean       @default(false) // ← NEW

  posts         ForumPost[]
  tags          ThreadTag[]
  followsThread Follow[]    @relation("FollowThread")

  @@unique([categoryId, slug])
  @@index([categoryId, createdAt])
}

model ForumPost {
  id        String      @id @default(cuid())
  threadId  String
  thread    ForumThread @relation(fields: [threadId], references: [id])
  authorId  String
  author    User        @relation(fields: [authorId], references: [id])
  content   Json
  markdown  String?
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  comments   Comment[]
  editAudits EditAudit[] // ← backref for EditAudit.post

  @@index([threadId, createdAt])
}

// ---------- Social ----------
model Comment {
  id       String @id @default(cuid())
  authorId String
  author   User   @relation(fields: [authorId], references: [id])

  // polymorphic target
  chapterId String?
  chapter   Chapter?   @relation(fields: [chapterId], references: [id])
  postId    String?
  post      ForumPost? @relation(fields: [postId], references: [id])

  parentId String?
  parent   Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies  Comment[] @relation("CommentReplies")

  content   Json
  markdown  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Tag {
  id         String      @id @default(cuid())
  name       String      @unique
  slug       String      @unique
  bookTags   BookTag[] // ← backrefs
  threadTags ThreadTag[]
}

model BookTag {
  bookId String
  tagId  String
  book   Book   @relation(fields: [bookId], references: [id])
  tag    Tag    @relation(fields: [tagId], references: [id])

  @@id([bookId, tagId])
}

model ThreadTag {
  threadId String
  tagId    String
  thread   ForumThread @relation(fields: [threadId], references: [id])
  tag      Tag         @relation(fields: [tagId], references: [id])

  @@id([threadId, tagId])
}

model Reaction {
  id         String         @id @default(cuid())
  userId     String
  user       User           @relation(fields: [userId], references: [id])
  targetType ReactionTarget
  targetId   String
  emoji      String         @default("like")
  createdAt  DateTime       @default(now())

  @@unique([userId, targetType, targetId, emoji])
}

model Follow {
  id         String @id @default(cuid())
  followerId String
  follower   User   @relation("UserFollows", fields: [followerId], references: [id])

  // targets
  userId String?
  user   User?   @relation("UserFollowers", fields: [userId], references: [id])
  bookId String?
  book   Book?   @relation(fields: [bookId], references: [id])

  threadId String?
  thread   ForumThread? @relation("FollowThread", fields: [threadId], references: [id])

  createdAt DateTime @default(now())

  @@unique([followerId, userId, bookId, threadId])
}

// ---------- Collaboration ----------
model Collaborator {
  id        String     @id @default(cuid())
  user      User       @relation(fields: [userId], references: [id])
  userId    String
  book      Book?      @relation(fields: [bookId], references: [id])
  bookId    String?
  page      Page?      @relation(fields: [pageId], references: [id])
  pageId    String?
  role      CollabRole
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@unique([userId, bookId, pageId])
}

model TurnQueue {
  id         String  @id @default(cuid())
  bookId     String
  book       Book    @relation(fields: [bookId], references: [id])
  userId     String
  user       User    @relation(fields: [userId], references: [id])
  order      Int
  timeoutSec Int     @default(172800) // 48h
  active     Boolean @default(true)

  @@unique([bookId, userId])
  @@unique([bookId, order])
}

model EditAudit {
  id        String     @id @default(cuid())
  userId    String
  user      User       @relation(fields: [userId], references: [id])
  chapterId String?
  chapter   Chapter?   @relation(fields: [chapterId], references: [id])
  postId    String?
  post      ForumPost? @relation(fields: [postId], references: [id])
  diff      Json
  createdAt DateTime   @default(now())
}

// ---------- RBAC ----------
model Role {
  id              String           @id @default(cuid())
  name            String           @unique
  userRoles       UserRole[]
  rolePermissions RolePermission[]
}

model Permission {
  id              String           @id @default(cuid())
  key             String           @unique
  description     String?
  rolePermissions RolePermission[]
}

model UserRole {
  userId String
  roleId String
  user   User   @relation(fields: [userId], references: [id])
  role   Role   @relation(fields: [roleId], references: [id])

  @@id([userId, roleId])
}

model RolePermission {
  roleId       String
  permissionId String
  role         Role       @relation(fields: [roleId], references: [id])
  permission   Permission @relation(fields: [permissionId], references: [id])

  @@id([roleId, permissionId])
}

// ---------- NextAuth ----------
model Account {
  id                String  @id @default(cuid())
  userId            String
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expires      DateTime
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum AuthCodePurpose {
  EMAIL_VERIFY
  PASSWORD_RESET
}

model AuthCode {
  id        String          @id @default(cuid())
  email     String
  purpose   AuthCodePurpose
  codeHash  String
  expiresAt DateTime
  tries     Int             @default(0)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  // важно: один активный код на email+purpose (чтобы resend перезаписывал)
  @@unique([email, purpose])
  @@index([email, purpose, expiresAt])
}


model Notification {
  id         String   @id @default(cuid())
  userId     String
  type       String
  actorId    String?
  targetType String
  targetId   String
  payload    Json?
  isRead     Boolean  @default(false)
  createdAt  DateTime @default(now())
  User       User     @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
}

model Subscription {
  id        String   @id @default(cuid())
  userId    String
  topicType String
  topicId   String
  level     String // ALL | MENTIONS | NONE
  createdAt DateTime @default(now())

  @@unique([userId, topicType, topicId])
}

model OutboxEvent {
  id         String   @id @default(cuid())
  kind       String
  entityType String
  entityId   String
  payload    Json?
  status     String   @default("pending")
  createdAt  DateTime @default(now())
}

model BookFollow {
  id        String   @id @default(cuid())
  userId    String
  bookId    String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
  book Book @relation(fields: [bookId], references: [id])

  @@unique([userId, bookId])
  @@index([bookId, createdAt])
}
